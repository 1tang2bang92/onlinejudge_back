**Title**: 기술 스택 결정 - 언어, 데이터베이스, 큐, 개발환경, 보안, 운영환경

**Status**: Accepted

### 1. 언어 선택
Context and Problem Statement:
프로젝트의 프로그래밍 언어를 결정해야 합니다. 이 언어는 개발 속도와 유지 보수성을 고려하여 선택해야 하며, 프론트엔드와의 일관성을 유지하는 것이 바람직합니다.

Decision:
JavaScript를 선택했습니다.

Considered Alternatives:
1. Python - 생산성이 높고, 커뮤니티가 강력하지만, JavaScript만큼의 프론트엔드와의 일관성은 부족합니다.
2. Java - 견고한 언어이지만, 상대적으로 학습 곡선이 가파르고, 생산성이 떨어질 수 있습니다.
3. Kotlin - 모던하고 강력한 언어지만, 기존 팀원들이 익숙하지 않아 학습 시간이 필요합니다.

Consequences:
JavaScript를 선택함으로써, 프론트엔드와 백엔드 간의 언어 일관성을 유지할 수 있으며, 개발 생산성이 극대화됩니다.

- Positive consequences:
    - 프론트엔드와의 코드 공유 및 협업이 용이함.
    - 대중적인 언어로, 개발자 풀과 라이브러리가 풍부함.

- Negative consequences:
    - 언어 자체가 대규모 시스템에서 성능이 떨어질 수 있음.
    - 동적 타이핑으로 인해 런타임 오류가 발생할 가능성이 있음.

### 2. 데이터베이스 선택
#### Context and Problem Statement:
백엔드 데이터베이스로 어떤 RDBMS를 사용할지 결정해야 합니다. 안정성, 기능 지원, 커뮤니티 지원이 중요한 요소입니다.

#### Decision:
PostgreSQL을 선택했습니다.

#### Considered Alternatives:
1. MySQL - 널리 사용되는 RDBMS이지만, PostgreSQL만큼 다양한 기능을 제공하지 않습니다.
2. MariaDB - MySQL의 포크로 성능 개선이 이루어졌지만, PostgreSQL의 기능적 장점을 가지고 있지 않습니다.

#### Consequences:
PostgreSQL을 사용함으로써 다양한 고급 기능을 활용할 수 있으며, 커뮤니티 지원이 강력합니다.
- Positive consequences:
    - 풍부한 기능과 확장성 제공.
    - ANSI SQL 준수로 표준성을 높임.
    - Row Level Security와 같은 고급 보안 기능 지원.
- Negative consequences:
    - 일부 상황에서 MySQL보다 성능이 떨어질 수 있음.
    - 복잡한 설정이 필요할 수 있음.

### 3. 큐 시스템 선택
#### Context and Problem Statement:
큐 시스템을 선택해야 합니다. 높은 트래픽 처리와 신뢰성 있는 메시지 전달이 중요한 요소입니다.

#### Decision:
Apache Kafka를 선택했습니다.

#### Considered Alternatives:
1. RabbitMQ - 메모리 기반 큐로, 성능은 좋지만, 서버가 중단되었을 때 데이터 손실 위험이 있습니다.
2. Pulsar - 고성능 큐이지만, Kafka에 비해 커뮤니티와 생태계가 약합니다.

#### Consequences:
Kafka를 사용함으로써 트래픽이 한 번에 몰릴 때도 높은 성능을 유지할 수 있으며, HDD에 데이터를 저장하여 안정성을 높일 수 있습니다.

- Positive consequences:
    - 고성능의 메시지 처리 가능.
    - 서버 중단 시에도 데이터 손실 없이 복구 가능.
- Negative consequences:
    - 설정과 운영이 복잡할 수 있음.
    - 학습 곡선이 있음.

### 4. 개발환경 선택
#### Context and Problem Statement:
개발 환경에서 컨테이너 솔루션을 선택해야 합니다. 개발 서버 없이 로컬에서 모든 것을 구성할 수 있는 솔루션이 필요합니다.

#### Decision:
Docker Compose를 선택했습니다.

#### Considered Alternatives:
1. Podman - Docker의 대안으로, 무겁지 않고 빠르지만, Docker만큼의 생태계와 호환성이 부족합니다.

#### Consequences:
Docker Compose를 사용하면 모든 구성 요소를 쉽게 설정할 수 있으며, 향후 eBPF와 같은 기술을 적용할 수 있습니다.

- Positive consequences:
    - 가장 널리 사용되는 컨테이너 솔루션으로, 지원과 문서가 풍부함.
    - 개발 서버 없이 로컬 환경에서 쉽게 설정 가능.
- Negative consequences:
    - 리소스 소모가 클 수 있음.
    - 초기 설정에 시간이 걸릴 수 있음.

### 5. 보안 설정
####  Context and Problem Statement:
시스템 전반에 대한 보안 설정을 결정해야 합니다. 리소스 접근을 강력히 제어할 필요가 있습니다.

#### Decision:
eBPF를 사용하기로 했습니다.

#### Considered Alternatives:
- N/A - 다른 대안은 특별히 고려하지 않음.

#### Consequences:
eBPF를 사용하여 시스템 콜을 제어함으로써, 원치 않는 리소스 접근을 효과적으로 차단할 수 있습니다.

- Positive consequences:
    - 운영체제 수준에서 강력한 보안 적용.
    - Docker와의 통합이 용이함.
- Negative consequences:
    - 복잡한 설정이 필요할 수 있음.
    - 일부 시스템에서 호환성 문제가 있을 수 있음.

### 6. 운영환경 선택
#### Context and Problem Statement:
운영 환경에서 사용할 플랫폼을 결정해야 합니다. 안정적이고 자동 확장이 가능한 플랫폼이 필요합니다.

#### Decision:
Kind를 사용하기로 했습니다.

#### Considered Alternatives:
1. K3s - 경량화된 Kubernetes 솔루션으로, 리소스가 적은 환경에 적합하지만, Kind만큼 간편하지 않을 수 있습니다.
2. K0s - 또 다른 경량 Kubernetes 배포판이지만, Kind와 달리 추가적인 설정이 필요할 수 있습니다.

#### Consequences:
Kind를 사용하여 도커만 설치된 환경에서도 쉽게 Kubernetes 클러스터를 운영할 수 있습니다.

- Positive consequences:
    - 도커만 설치되어 있으면 어디서나 실행 가능.
    - 간편한 설정과 관리.
- Negative consequences:
    - 대규모 환경에서의 사용에는 제한이 있을 수 있음.
    - 복잡한 사용 사례에서는 추가 설정이 필요할 수 있음.

Related ADRs:
- N/A

Date: 2023-08-10