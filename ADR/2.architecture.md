언어: js

대안: python, java, kotlin

선택한 이유:
대중적인 언어들중 다루기 쉽고 빠르면서 견고한 설계를 지원하는 언어들중 생산성이 빠른 언어를 선택함.
또한 생산성 극대화를 위해 frontend와 같은 언어를 선택함.

---

데이터베이스: postgresql

대안: mysql, mariadb

선택한이유:
오픈소스 RDBMS중 가장 많은 기능을 지원하고, 커뮤니티가 탄탄하며, ANSI SQL을 최대한 따르려고 노력하며, row level security를 지원하기 떄문에 선택함.

---

큐: kafka

대안: rabbitmq, pulsar

선택한이유:
서버가 꺼지더라도 재챗점과 같은 로직들이 제대로 수행됬으면 하는 바람에 HDD에 저장이 가능한 큐를 선택함.
또한 이 프로그램이 쓰일곳은 보통 알고리즘 수업시간일텐데, 트래픽이 한 번에 많이 몰리고 사라질거라 고성능의 큐가 필요했음.

---

개발환경: docker compose

대안: podman

선택한 이유:
container 솔루션중 가장 유명하고, 개발서버를 따로 두지 않아도 docker-compose만 있다면 서버의 모든 구성요소를 한 번에 띄울 수 있기 떄문에 선택함.
또한 차후 적을 eBPF를 적용가능했음.

---

보안: eBPF

선택한이유:
systemcall 자체를 모두 막아버릴 수 있어 내가 원치않는 리소스로의 접근을 모두 차단하기 위해 운영체제 수준에서 모든것을 막기로 결정함.
docker container를 생성할때 옵션으로 제한할 수 있으므로 추가 개발이 필요치않았음.

---

운영환경: kind

대안: k3s, k0s

선택한이유:
트래픽이 몰릴떄 autoscale을 하고싶은데 추가 개발없이 안전한 플랫폼인 쿠버네티스 배포판들을 이용하기로함.
이를 위한 다양한 쿠버네티스 프로젝트들중 도커만 설치되 있다면 실행가능한 kind를 선택함.
차후 서버가 추가되더라도 쿠버네티스 slave node를 추가할 여력이 없을거같아 kind를 활용하는것이 좋다고 판단함.
